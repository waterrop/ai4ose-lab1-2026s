# Day 1 执行单：打基础（ch1/ch2）

## 今日目标

- 跑通 `ch1/ch2` 的构建与运行流程。
- 讲清楚 `-bios none`、`U/S` 特权级、`ecall -> trap` 基本链路。
- 建立后续 5 天可复用的“学习-编码-输出”模板。

## 时间切片（建议）

- 09:00-11:30 输入学习：阅读 `ch1/README.md` 与 `ch2/README.md`
- 14:00-17:30 实践验证：执行命令并记录结果
- 19:30-21:30 费曼输出：讲解稿 + 章节改进清单

## 实践步骤

### A. ch1 验证

```bash
cd /home/chyyuu/thecodes/ai4ose/rCore-Tutorial-in-single-workspace/ch1
cargo build
cargo run
```

通过标准：
- 能看到 `Hello, world!` 输出并正常退出。

### B. ch2 验证

```bash
cd /home/chyyuu/thecodes/ai4ose/rCore-Tutorial-in-single-workspace/ch2
cargo build
cargo run
./test.sh
```

通过标准：
- 批处理应用可依次运行，基础测试通过或明确失败用例。

## D1 概念卡片（建议背诵）

1. 应用执行环境不是“黑盒”，它由启动流程、内存布局和特权约束共同构成。
2. `-bios none` 表示不依赖外部固件，入口与最小运行时需自行提供。
3. `ecall` 是用户态主动进入内核态的合法通道。
4. Trap 处理核心是“保存上下文 -> 分发处理 -> 恢复上下文”。
5. 批处理 OS 是“自动串行化执行多个应用”的最小 OS 形态。
6. `write` 与 `exit` 是最小系统调用闭环的典型代表。
7. 用户态与内核态隔离是安全与稳定的前提。
8. 系统调用本质是受控特权提升。
9. 构建脚本在 OS 项目中通常负责“打包用户程序 + 生成链接信息”。
10. 测试脚本的价值是让“行为回归”可重复。

## D1 费曼讲解稿（5分钟骨架）

1. 为什么一个 `Hello world` 在 OS 里不简单。
2. 程序如何从入口开始跑起来（启动与链接）。
3. 用户程序如何请求内核服务（`ecall`）。
4. Trap 发生后内核做了什么。
5. 为什么要有特权级和隔离。
6. ch1/ch2 各自解决了什么问题。

## D1 章节改进清单

### ch1 改进建议
- 增加“启动路径一图流”，把入口、栈、输出、关机串起来。
- 增加“最小排错指南”（QEMU 无输出、工具链不匹配、目标架构未添加）。
- 增加“关键术语卡片”（SBI、裸机、交叉编译、链接脚本）。

### ch2 改进建议
- 增加“Trap 全链路时序图”。
- 增加“系统调用参数传递示例”。
- 增加“批处理与多道程序对比表”。

## Day 1 验收清单

- [ ] ch1 `cargo build` 成功
- [ ] ch1 `cargo run` 输出正确
- [ ] ch2 `cargo build` 成功
- [ ] ch2 `cargo run` 成功
- [ ] ch2 测试脚本已执行并记录结果
- [ ] 完成 D1 费曼讲解稿
- [ ] 完成 ch1/ch2 各 >=3 条改进建议
