# 

今天我们要讲的是os运行的最小环境和os是如何运行的

我们先看一下println!("Hello, world!");这行代码是如何在os里执行的。

```
println!("Hello, world!"); -> Rust 标准库 -> libc -> 系统调用 write -> Linux 内核 -> 串口驱动 -> 硬件显示
```

可以看到这行代码的执行经过了很多的步骤，最终才在屏幕上打印出了"Hello, world!"

那么为什么要执行这么多层呢？我直接在屏幕上写不行吗？

这是因为计算机硬件有很多，并且计算机硬件只认识0或1，如果我们人类自己使用的话会很麻烦，所以我们想到使用一个程序来帮我们管理所有计算机硬件，这就是操作系统（简称os）。我们可以把os看成一个大管家，所有所有硬件资源都由它统一管理。你的程序只是众多房客之一，不能随便触碰硬件，必须通过管家（内核）来做事。

# 一、管家和房客：特权级的由来

为了让os这个大管家正常管理硬件资源，CPU为硬件设计了**不同的特权级别**。

以RISC-V架构为例，特权级有三个等级：
- **M模式**（机器态）：最底层，运行**固件**（比如开机时负责初始化硬件的程序）。
- **S模式**（监管态）：运行**操作系统内核**——我们的管家。
- **U模式**（用户态）：运行**应用程序**——各位房客。

**特权级隔离**的意义就在这儿：房客（U 模式）不能随意访问管家的私人数据，更不能乱动硬件，否则整栋楼可能崩溃。想打印？只能通过**系统调用**，礼貌地请管家帮忙。

# 二、房客如何呼叫管家？—— `ecall`

在 RISC‑V 里，系统调用的指令就是`ecall`（Environment Call）。

当你调用`write`时，标准库会在适当位置插入这条指令，并且把：
- **系统调用号**（比如`write`是 64 号）放进`a7`寄存器
- **参数**（文件描述符、缓冲区地址、长度）分别放进`a0`、`a1`、`a2`

然后执行 ecall —— 就像按下门铃，CPU 立刻从**U 模式陷入 S 模式**，跳转到内核提前设置好的**Trap入口**。

# 三、Trap：从按下门铃到管家响应

**Trap**是 CPU 处理异常或中断的统一机制。

## 1.硬件自动完成（瞬间动作）
- 把当前指令地址保存到`sepc`（这样以后还能回来）。
- 把当前特权级（U）记录到`sstatus.SPP`。
- 把 Trap 原因写入`scause`（系统调用的原因是 8）。
- 从`stvec`寄存器读出内核写好的入口地址，PC 直接跳过去。
- 特权级自动变成 S 模式。

## 2. 软件接管（内核的 Trap 处理函数）
入口地址对应的代码叫做`__alltraps`，它的第一件事是把用户程序所有的寄存器都保存到内核栈（这叫 Trap 上下文），因为马上要用内核的寄存器了，不能把用户的数据弄丢。

接着调用 Rust 写的`trap_handler`：
```
match scause 的原因 {
    8 => {  // 系统调用
        根据 a7 分发到具体内核函数（如 sys_write）；
        处理完后把 sepc 加上 4，跳过 ecall 指令；
    }
    _ => {  // 其他异常，比如非法指令
        直接杀死程序；
    }
}
```
## 3. 返回房客
处理完毕后，`__restore`把刚才保存的用户寄存器全部恢复，执行 sret 指令。
CPU 根据`sstatus.SPP`知道之前是 U 模式，于是切回 U 模式，pc 被设回`sepc`（此时已 +4），用户程序从`ecall`的下一条指令继续执行。

# 流程图回顾
```
用户程序执行 ecall
   ↓
【硬件】保存 sepc、scause，跳转 stvec，切 S 模式
   ↓
内核 __alltraps → 保存用户寄存器
   ↓
trap_handler 根据 scause 分发 → 系统调用 → 修改 sepc += 4
   ↓
__restore → 恢复寄存器 → sret 回 U 模式
   ↓
用户程序继续运行
```

# 五、所以，一个 Hello World 到底经历了什么？

打印一句话，背后有：
- 标准库把 println! 转成 write 系统调用；
- ecall 触发 Trap，硬件/软件合作保存现场、进入内核；
- 内核的 sys_write 把字符串传给终端驱动；
- 驱动操作硬件，屏幕上终于出现了字。

第一章我们做的就是：不给操作系统，纯粹在裸机上让一个程序跑起来——自己写启动代码、自己处理退出，这叫最小运行时环境。

第二章则让多个程序串行执行：一个跑完再跑下一个，初步有了“多道程序”的雏形。

现在你明白了：一个简单的打印，其实是应用、标准库、内核、固件、硬件层层配合的结果。而这一切的核心，就是通过 Trap 机制实现安全的特权级切换。