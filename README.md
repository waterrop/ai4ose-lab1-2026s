# 第一章

操作系统内核编程语言是Rust，操作系统内核基于的硬件环境是RISC-V 64，操作系统内核实验在QEMU模拟器上运行。要求基于Rust Crate组件化编程，即每个内核或内核模块是可以发布到crates.io上的条件（cargo publish --dry-run 成功运行）

第一章旨在引导你构建一个尽量简单的**特权态裸机应用程序**：

- 什么是特权态裸机应用程序？它与构建操作系统是什么关系？
特权态是**CPU硬件提供的一种权限机制**，拥有对所有硬件的完全控制权。引导加载程序（如RustSBI）或最底层固件就运行在此态。
裸机是指程序的运行环境，即程序直接运行在硬件上。
所以我们要构建的特权态裸机应用程序是一种直接运行在硬件上的应用程序。
- 为什么从构建特权态裸机应用程序开始？
- 如何构建一个特权态裸机应用程序？
    计算机硬件只能识别二进制01，我们用一系列01串即指令，来控制计算机硬件。
    内核的硬件环境是RISC-V 64，而大部分人的电脑不支持RISC-V 64架构，所以我们使用QEMU模拟RISC-V 64硬件环境。
    使用build.rs定制链接脚本，将主函数、栈放进内存段的相应位置


- 为什么一个Hello World在os里不简单？

当我们在 Linux 上执行 println!("Hello, world!") 时，实际经历了：println! → Rust 标准库 → libc 的 write() → Linux 内核 sys_write 系统调用 → 串口/终端驱动 → 硬件显示。
经历如此多的过程是因为我们应用程序运行在一个执行环境栈中：
```
  ┌─────────────────────────┐
  │      应用程序            │  ← 你写的代码
  ├─────────────────────────┤
  │   标准库 (std / libc)    │  ← println! 等函数的实现
  ├─────────────────────────┤
  │     操作系统内核         │  ← 系统调用：write, exit 等
  ├─────────────────────────┤
  │固件层 (如RISC-V的SBI实现)│  ← 固件，为内核提供基础服务
  ├─────────────────────────┤
  │       硬件 (CPU/内存)    │  ← 物理硬件
  └─────────────────────────┘
```
每一层为上一层提供服务、层与层之间有明确的接口定义，通过接口交互：
- 应用程序通过**系统调用**（如`ecall`）请求操作系统服务
- 操作系统通过**SBI调用**请求固件服务
- 固件直接操作硬件

由此可见，想打印一个Hello World不简单！

- 程序如何从入口跑起来？

程序是一系列指令，CPU执行了这些指令就是程序跑起来了，所以想让程序从入口跑起来就要让程序的第一条指令存到入口地址的位置，这样就可以跑起来了。

- 用户程序如何请求内核服务`ecall`？

在需要请求操作系统服务的位置插入`ecall`指令即可。

- Trap 发生后内核做了什么？

Trap 发生后，首先由硬件自动将当前指令地址保存到 sepc ，并记录陷入前的特权级，并切换到内核态，CPU 从 stvec 寄存器读出 Trap 处理函数的地址，并跳转到那里，然后保存用户的所有寄存器信息，读取 scause 判断是系统调用还是其他异常，跳转到内核相应的中断处理程序进行处理，处理结束后从内核栈恢复用户寄存器信息，执行 sret 返回 U-mode ，然后用户程序从 `ecall` 的下一条指令执行。

**Trap处理流程**

```
用户程序执行 ecall
       │
       ▼
  ┌── 硬件自动完成 ──┐
  │ 1. sstatus.SPP ← U  │  （记录 Trap 前的特权级）
  │ 2. sepc ← ecall 地址  │  （记录 Trap 前的 PC）
  │ 3. scause ← 原因      │  （如 UserEnvCall）
  │ 4. PC ← stvec         │  （跳转到 Trap 入口）
  │ 5. 特权级 ← S-mode    │  （切换到内核态）
  └──────────────────────┘
       │
       ▼
  Trap 入口（__alltraps）
  ── 保存所有用户寄存器到内核栈（Trap 上下文）
  ── 跳转到 Rust 的 trap_handler
       │
       ▼
  trap_handler 处理
  ── 读取 scause 判断 Trap 类型
  ── 系统调用：处理后 sepc += 4（跳过 ecall 指令）
  ── 异常：杀死程序
       │
       ▼
  __restore
  ── 从内核栈恢复用户寄存器
  ── 执行 sret 返回 U-mode
       │
       ▼
  用户程序从 ecall 的下一条指令继续执行
```

- 为什么要有特权级和隔离？

因为操作系统向上提供的资源很多，用户操作不当会引起系统崩溃，所以需要分出特权级进行隔离。

- ch1/ch2 各自解决了什么问题？

1. ch1解决了最小的运行时环境，即让一个程序能编译、链接、运行的最基本条件。
2. ch2解决了多个程序在操作系统中的串行执行。









## 编译
在根目录下键入cargo build -p ch1 --target riscv64gc-unknown-none-elf

## 使用qemu运行（需提前在根目录安装好rustsbi-qemu.bin）
在ch1/下键入qemu-system-riscv64 -machine virt -nographic -bios rustsbi-qemu.bin -kernel target/riscv64gc-unknown-none-elf/debug/ch1

# 第二章
做批处理系统前，先解决链接脚本问题
每次都要手动写链接脚本太麻烦了，这一章引导你建立模块，可以控制内核链接脚本的结构
链接器（不是编译原理里的那个链接器）的作用是把内存段分配清楚，批处理系统通过链接器把多个应用链接进系统里，所以链接器需要抽象出应用程序的一些特征来把多个应用程序放到对应的内存段中