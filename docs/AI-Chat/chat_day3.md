1. 使用DeepSeek进行环境搭建

prompt：我在使用vscode进行项目的开发，我该如何使用vscode的copilot

根据回答成功使用copilot

2. 在copilot里询问ch3里trace实现的逻辑bug

prompt：@workspace 根据ch3的readme.md要实现的系统调用trace，找出目前main.rs里trace的实现的逻辑bug

并没有得到想要的答案，还有一些ch3里不存在的变量，但是提到了系统调用计数逻辑的问题，还是prompt不够细致。

3. 演讲稿审阅，DeepSeek

prompt：我在进行费曼演讲稿的编写，这是我的讲解稿：
`- 为什么一个Hello World在os里不简单？

当我们在 Linux 上执行 println!("Hello, world!") 时，实际经历了：println! → Rust 标准库 → libc 的 write() → Linux 内核 sys_write 系统调用 → 串口/终端驱动 → 硬件显示。
经历如此多的过程是因为我们应用程序运行在一个执行环境栈中：
```
  ┌─────────────────────────┐
  │      应用程序            │  ← 你写的代码
  ├─────────────────────────┤
  │   标准库 (std / libc)    │  ← println! 等函数的实现
  ├─────────────────────────┤
  │     操作系统内核         │  ← 系统调用：write, exit 等
  ├─────────────────────────┤
  │   硬件抽象层 (SBI/BIOS)  │  ← 固件，为内核提供基础服务
  ├─────────────────────────┤
  │       硬件 (CPU/内存)    │  ← 物理硬件
  └─────────────────────────┘
```
每一层为上一层提供服务、层与层之间有明确的接口定义，通过接口交互：
- 应用程序通过**系统调用**（如`ecall`）请求操作系统服务
- 操作系统通过**SBI调用**请求固件服务
- 固件直接操作硬件

由此可见，想打印一个Hello World不简单！

- 程序如何从入口跑起来？

程序是一系列指令，CPU执行了这些指令就是程序跑起来了，所以想让程序从入口跑起来就要让程序的第一条指令存到入口地址的位置，这样就可以跑起来了。

- 用户程序如何请求内核服务`ecall`？

在需要请求操作系统服务的位置插入`ecall`指令即可。

- Trap 发生后内核做了什么？

Trap发生后，首先由硬件自动保存用户的PC信息，并切换到内核态，跳到`stvec`保存的Trap入口处，然后保存用户的所有寄存器信息，判断中断类型，跳转到内核相应的中断处理程序进行处理，处理结束后从内核栈恢复用户寄存器信息，执行sret返回U-mode，然后用户程序从`ecall`的下一条指令执行。

**Trap处理流程**

```
用户程序执行 ecall
       │
       ▼
  ┌── 硬件自动完成 ──┐
  │ 1. sstatus.SPP ← U  │  （记录 Trap 前的特权级）
  │ 2. sepc ← ecall 地址  │  （记录 Trap 前的 PC）
  │ 3. scause ← 原因      │  （如 UserEnvCall）
  │ 4. PC ← stvec         │  （跳转到 Trap 入口）
  │ 5. 特权级 ← S-mode    │  （切换到内核态）
  └──────────────────────┘
       │
       ▼
  Trap 入口（__alltraps）
  ── 保存所有用户寄存器到内核栈（Trap 上下文）
  ── 跳转到 Rust 的 trap_handler
       │
       ▼
  trap_handler 处理
  ── 读取 scause 判断 Trap 类型
  ── 系统调用：处理后 sepc += 4（跳过 ecall 指令）
  ── 异常：杀死程序
       │
       ▼
  __restore
  ── 从内核栈恢复用户寄存器
  ── 执行 sret 返回 U-mode
       │
       ▼
  用户程序从 ecall 的下一条指令继续执行
```

- 为什么要有特权级和隔离？

因为操作系统向上提供的资源很多，用户操作不当会引起系统崩溃，所以需要分出特权级进行隔离。

- ch1/ch2 各自解决了什么问题？

1. ch1解决了最小的运行时环境，分析了一个程序运行在计算机上的最小环境。
2. ch2解决了多个程序在操作系统中的串行执行。
`

请严格审查并输出：
1. 逻辑跳步位置；
2. 术语误用；
3. 缺失前提；
4. 面向大二学生的改写版（5分钟）。